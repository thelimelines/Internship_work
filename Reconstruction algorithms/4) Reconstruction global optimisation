
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit, dual_annealing

# Load the data
data = pd.read_csv('mode_data_test.csv')

# Define the even symmetric Fourier series function
def even_symmetric_fourier_series(x, *coeffs):
    """Even symmetric Fourier series representation using only cosine terms."""
    a0 = coeffs[0]
    result = a0
    for n in range(1, len(coeffs)):
        an = coeffs[n]
        result += an * np.cos(2 * n * np.pi * x / 180)
    return result

# Identify unique modes in the data
unique_modes = data[['Mode m', 'mode n']].drop_duplicates().values

# Initialize a dictionary to store Fourier coefficients for each mode
even_symmetric_fourier_coefficients = {}

# Fit the even symmetric Fourier series for each unique mode using data in the range [0, 90]
for mode in unique_modes:
    m, n = mode
    mode_data = data[(data['Mode m'] == m) & (data['mode n'] == n)]
    
    # Adjust the number of terms based on m
    n_terms_adjusted = m + 1
    
    # Filter data for x in [0, 90]
    mode_data = mode_data[mode_data['Polarization'] <= 90]
    
    x_data = mode_data['Polarization'].values
    y_data = np.nanmean([mode_data['Power1'].values, mode_data['Power2'].values], axis=0)
    
    # Fit the Fourier series to the data with adjusted number of terms
    popt, _ = curve_fit(even_symmetric_fourier_series, x_data, y_data, p0=[1.0] + [0.0] * n_terms_adjusted)
    even_symmetric_fourier_coefficients[(m, n)] = popt

# Function to simulate signal with polarization shift
def simulate_signal_with_polarization_shift(x_values, fourier_coefficients, weights, polarization_shifts):
    simulated_signal = np.zeros_like(x_values)
    for (m, n), weight, shift in zip(fourier_coefficients.keys(), weights, polarization_shifts):
        coeffs = fourier_coefficients[(m, n)]
        shifted_x = (x_values + shift) % 180
        individual_mode_signal = weight * even_symmetric_fourier_series(shifted_x, *coeffs)
        simulated_signal += individual_mode_signal
    return simulated_signal

# Objective function returning a scalar sum of squared residuals
def objective_scalar(params, x, y, fourier_coefficients):
    n_modes = len(fourier_coefficients)
    weights = params[:n_modes]
    shifts = params[n_modes:]
    simulated_y = simulate_signal_with_polarization_shift(x, fourier_coefficients, weights, shifts)
    residual = y - simulated_y
    return np.sum(residual ** 2)

# Synthetic Fourier coefficients for three modes (LP11, LP21, and LP02)
even_symmetric_fourier_coefficients = {(1, 1): [1.0, 0.5], (2, 1): [0.8, 0.3], (0, 2): [0.9, 0.4]}

# Generate the original synthetic signal
x_values = np.linspace(0, 180, 1000)
weights = [0, 0, 18]
polarization_shifts = [0, 60, 15]
original_signal_values = simulate_signal_with_polarization_shift(x_values, even_symmetric_fourier_coefficients, weights, polarization_shifts)

# Sample the original signal at 12 equally spaced points
n_points = 12
sample_indices = np.linspace(0, len(x_values) - 1, n_points, dtype=int)
sampled_x = x_values[sample_indices]
sampled_y = original_signal_values[sample_indices]

# Set the bounds for the optimization (weights between 0 and 5, shifts between 0 and 180 degrees)
bounds = [(0, 5)] * len(even_symmetric_fourier_coefficients) + [(0, 180)] * len(even_symmetric_fourier_coefficients)

# Perform global optimization using Simulated Annealing
result = dual_annealing(objective_scalar, bounds, args=(sampled_x, sampled_y, even_symmetric_fourier_coefficients), maxiter=1000, initial_temp=5230)

# Extract the optimized parameters
recovered_params = result.x
recovered_weights = recovered_params[:len(even_symmetric_fourier_coefficients)]
recovered_shifts = recovered_params[len(even_symmetric_fourier_coefficients):]

# Generate the recovered signal using the optimized parameters
recovered_signal_values = simulate_signal_with_polarization_shift(x_values, even_symmetric_fourier_coefficients, recovered_weights, recovered_shifts)

# Plot the original and recovered signals
plt.figure(figsize=(12, 6))
plt.plot(x_values, original_signal_values, label='Original Signal', linewidth=2)
plt.plot(x_values, recovered_signal_values, label='Recovered Signal', linestyle='--', linewidth=2)
plt.scatter(sampled_x, sampled_y, label='Sampled Points', color='red', s=50, zorder=5)
plt.xlabel('Polarization (degrees)')
plt.ylabel('Power (W)')
plt.title('Original and Recovered Signals')
plt.legend()
plt.show()